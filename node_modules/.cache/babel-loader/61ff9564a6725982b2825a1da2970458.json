{"ast":null,"code":"import { Weather } from \"./Weather\";\nexport const getDayStr = date => {\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  return days[date.getUTCDay()];\n};\n\nconst normaliseTime = time => {\n  return time < 10 ? '0' + time : time;\n};\n\nexport const getTimeStr = date => {\n  const h = date.getUTCHours();\n  const m = date.getUTCMinutes();\n  return `${normaliseTime(h)}:${normaliseTime(m)}`;\n};\nexport const parseWeatherResponse = weatherResponse => {\n  return new Weather(weatherResponse);\n};\n/**\n *\n * @param {Object[]} list WeatherResponse\n * @returns {Promise<Weather[]>}\n */\n\nexport const reduceForecast = (list = []) => {\n  const groupedForecastByDays = [];\n  let i = 0;\n  let finished = false;\n\n  while (!finished) {\n    for (let j = 0; j < list.length; j += 1) {\n      const tmp = parseWeatherResponse(list[j]);\n\n      if (!groupedForecastByDays[i]) {\n        groupedForecastByDays.push([tmp]);\n      } else {\n        if (tmp.date.getDay() === groupedForecastByDays[i][groupedForecastByDays[i].length - 1].date.getDay()) {\n          groupedForecastByDays[i].push(tmp);\n        } else {\n          i++;\n        }\n      }\n\n      if (j === list.length - 1) {\n        finished = true;\n      }\n    }\n  }\n\n  const checkProperty = (weather, weatherData) => {\n    for (let key in weather) {\n      if (weather.hasOwnProperty(key)) {\n        if (typeof weather[key] === \"number\" && key.indexOf('max') >= 0 && weather[key] > weatherData[key]) {\n          weatherData[key] = weather[key];\n        } else if (typeof weather[key] === \"number\" && key.indexOf('min') >= 0 && weather[key] < weatherData[key]) {\n          weatherData[key] = weather[key];\n        } else if (typeof weather[key] === \"number\" && weather[key] > weatherData[key]) {\n          weatherData[key] = weather[key];\n        } else if (weatherData[key] instanceof Date) {\n          weatherData[key] = weather[key];\n        } else if (typeof weather[key] === \"object\") {\n          checkProperty(weather[key], weatherData[key]);\n        }\n      }\n    }\n  };\n\n  const forecast = groupedForecastByDays.reduce((days, weatherForDay) => {\n    const weatherData = weatherForDay[0];\n\n    for (let weather of weatherForDay) {\n      checkProperty(weather, weatherData);\n    }\n\n    days.push(weatherData);\n    return days;\n  }, []);\n  return forecast;\n};\nexport const makeUrl = (url, query) => {\n  if (query.q) {\n    url += `&q=${query.q}`;\n  } else if (query.lon && query.lat) {\n    url += `&lat=${query.lat}&lon=${query.lon}`;\n  }\n\n  return url;\n};","map":{"version":3,"sources":["/Users/macuser/Projects/weather_app/src/Utils.js"],"names":["Weather","getDayStr","date","days","getUTCDay","normaliseTime","time","getTimeStr","h","getUTCHours","m","getUTCMinutes","parseWeatherResponse","weatherResponse","reduceForecast","list","groupedForecastByDays","i","finished","j","length","tmp","push","getDay","checkProperty","weather","weatherData","key","hasOwnProperty","indexOf","Date","forecast","reduce","weatherForDay","makeUrl","url","query","q","lon","lat"],"mappings":"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","sourcesContent":["import { Weather } from \"./Weather\";\n\nexport const getDayStr = (date) => {\n\tconst days = [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', ];\n\treturn days[date.getUTCDay()];\n};\n\nconst normaliseTime = (time) => {\n\treturn time < 10 ? '0' + time : time;\n}\n\nexport const getTimeStr = (date) => {\n\tconst h = date.getUTCHours();\n\tconst m = date.getUTCMinutes();\n\treturn `${ normaliseTime(h) }:${ normaliseTime(m) }`\n};\n\nexport const parseWeatherResponse = (weatherResponse) => {\n\treturn new Weather(weatherResponse)\n};\n/**\n *\n * @param {Object[]} list WeatherResponse\n * @returns {Promise<Weather[]>}\n */\nexport const reduceForecast = (list = []) => {\n\tconst groupedForecastByDays = [];\n\tlet i = 0;\n\tlet finished = false;\n\twhile (!finished) {\n\t\tfor (let j = 0; j < list.length; j += 1) {\n\t\t\tconst tmp = parseWeatherResponse(list[j]);\n\t\t\tif (!groupedForecastByDays[i]) {\n\t\t\t\tgroupedForecastByDays.push([ tmp ]);\n\t\t\t} else {\n\t\t\t\tif (tmp.date.getDay() === groupedForecastByDays[i][groupedForecastByDays[i].length - 1].date.getDay()) {\n\t\t\t\t\tgroupedForecastByDays[i].push(tmp);\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j === list.length - 1) {\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst checkProperty = (weather, weatherData) => {\n\t\tfor (let key in weather) {\n\t\t\tif (weather.hasOwnProperty(key)) {\n\t\t\t\tif (typeof weather[key] === \"number\" && key.indexOf('max') >= 0  && weather[key] > weatherData[key]) {\n\t\t\t\t\tweatherData[key] = weather[key]\n\t\t\t\t} else if (typeof weather[key] === \"number\" && key.indexOf('min') >= 0 && weather[key] < weatherData[key]) {\n\t\t\t\t\tweatherData[key] = weather[key]\n\t\t\t\t} else if (typeof weather[key] === \"number\" && weather[key] > weatherData[key]) {\n\t\t\t\t\tweatherData[key] = weather[key]\n\t\t\t\t} else if (weatherData[key] instanceof Date) {\n\t\t\t\t\tweatherData[key] = weather[key]\n\t\t\t\t} else if (typeof weather[key] === \"object\") {\n\t\t\t\t\tcheckProperty(weather[key], weatherData[key])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tconst forecast = groupedForecastByDays.reduce((days, weatherForDay) => {\n\t\tconst weatherData = weatherForDay[0];\n\t\tfor (let weather of weatherForDay) {\n\t\t\tcheckProperty(weather, weatherData)\n\t\t}\n\t\tdays.push(weatherData);\n\t\treturn days;\n\t}, []);\n\treturn forecast;\n};\n\n\nexport const makeUrl = (url, query) => {\n\tif (query.q) {\n\t\turl += `&q=${ query.q }`;\n\t} else if (query.lon && query.lat) {\n\t\turl += `&lat=${ query.lat }&lon=${ query.lon }`;\n\t}\n\n\treturn url;\n}\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}